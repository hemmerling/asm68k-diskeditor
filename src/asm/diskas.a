* * FILE: sDISKAS ** Copyright 1988-2015 Rolf Hemmerling** Licensed under the Apache License, Version 2.0 (the "License");* you may not use this file except in compliance with the License.* You may obtain a copy of the License at** http://www.apache.org/licenses/LICENSE-2.0** Unless required by applicable law or agreed to in writing,* software distributed under the License is distributed on an* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,* either express or implied.* See the License for the specific language governing permissions* and limitations under the License.** Letztes Update: 1988-05-12 * ** BUFFER FUER DMA*  EIGENES MODUL,DAMIT LEICHTER AUFFINDBAR*  MUSS MINDESTENS 6250 BYTES LANG SEIN *  (DATA BECKER FLOPPY SEITE 161)*  HIER AUFGERUNDET AUF $2000 BYTES SEIN**  ABER: DIE AN DMA UEBERGEBENE SECMAX MUSS  *  GROESSER SEIN ALS DIE ZU TRANSFERIERENDE*  ANZAHL VON 512 BYTE BLOECKEN, ACHTUNG BESONDERS BEI*  READ SECTOR WITH M-BIT,READ TRACK, SONST ZUVOR*  ABBRUCH*  SO ABER IMMER DAS DMA STATUS BIT GESETZT: SECCOUNT <> 0*BUFSIZ     EQU     $2000 SECMAX     EQU     BUFSIZ/512   ;FUER DMA SECTOR COUNT** MODULE HEAD FOR RTOS            DC.L    0,0         ;FOR LOADER            DC      $0010       ;TYPE: MDLE            DC.B    'BUFFER'   ;6 BYTES NAME-LINK *>BUFFER    DS      BUFSIZ      ;SOVIEL PLATZ FUER BUFFER             *** ARRAY-DEFINITIONEN FUER FLOPPYBUFFER* SPC PUFFER(8192) CHAR(1) GLOBAL;*>PUFFER    DS      0           DC      BUFSIZ           DC.L    BUFFER-1  ;DARF NICHT >BUFFER HEISSEN** MODULE HEAD FOR RTOS *           DC.L    0,0         ;FOR LOADER            DC      $0010       ;TYPE: MDLE            DC.B    'MASCHR'    ;6 BYTES NAME-LINK * * INCLUDE 'sINCLAS' * +1-614 * * PWS - DEFINITION * FSTAT: STATUS     EQU      0          ;.L (CALL BY ADR = RETURN VALUE) * SELDRV: WDRIVE     EQU      4          ;.W (CALL BY VALUE) WSIDE      EQU      6          ;.W (CALL BY VALUE) * SETDMA,RSTRCK,READSC,WRITS:BUFPTR     EQU      8          ;.L (CALL BY VALUE) POINTER TO BUFFER SECR       EQU     12          ;.W (CALL BY VALUE)DATAMK     EQU     14          ;.W (CALL BY VALUE)*SEEKT0: FDCERR     EQU     16          ;.L (CALL BY ADR = RETURN VALUE) *SETVEC,GETVEC VECNO      EQU     20          ;.W (CALL BY VALUE) VECNEU     EQU     22          ;.L (CALL BY VALUE) VECTOR POINTER VECALT     EQU     26          ;.L (CALL BY ADR = RETURN VALUE) *SUSPUT,CONTUT UTNAME     EQU     30          ;.L NAME DER TASK (6 BYTES INSGESAMT) *                              ;.W NAMEND     EQU     36          ;.W ABSCHLUSS MIT $FF $FF *SRCHMD: MDFND      EQU     38          ;.L (CALL BY ADR = RETURN VALUE) * DOSVEC: ZECNO      EQU     42          ;.W (CALL BY VALUE) ZECNEU     EQU     44          ;.L (CALL BY VALUE) VECTOR POINTER ZECALT     EQU     48          ;.L (CALL BY ADR = RETURN VALUE) * SEEKTR: TRACK      EQU     52          ;.W (CALL BY VALUE) TRACKR     EQU     54          ;.L (CALL BY ADR = RETURN VALUE) * GETBUFBUFADR     EQU     58          ;.L (CALL BY ADR = RETURN VALUE)* GETSECSECTOR     EQU     62          ;.L (CALL BY ADR = RETURN VALUE)*WSPSZ      EQU     66 * * RESET THE FDC *  SPC RESET ENTRY GLOBAL; *  CALL RESET; * FINTR      EQU     $D0             ;TERMINATE WITHOUT INTERRUPT * >RESET     ENTR    WSPSZ.L            EPAR            OFF            MOVE.W  =FINTR,DSKDAT            ANDI    =$D8FF,SR            RETN * * READ THE STATUS REGISTER *  SPC FSTAT ENTRY RETURNS(FIXED(16)) GLOBAL; *  DCL STATUS FIXED(15); *  STATUS = FSTAT; * ZERSTOERTE REGS: D2,A3 * >FSTAT     ENTR    WSPSZ.L            VARW    STATUS.Z            EPAR            OFF ** DMA STATUS REGISTER LESEN*           MOVE.W  DMASTA,D2           ANDI.W  =$0007,D2 ;DMA STATUS IST 3 BIT BREIT            ASL.W   =BYTE,D2  ;STATUS IN HIGH BYTE SCHIEBEN* * FDC STATUSREGISTER LESEN *            MOVE.W  =(FLOPPY+FRSTAT),DMACTL ;ZUGRIFF AUF FDC STATUSREG            MOVE.W  DSKDAT,D3               ;FDC STATUS LESEN            ANDI.W  =$00FF,D3               ;FDC REGISTER IST 8BIT BREIT            OR.W    D2,D3                   ;FDC,DMA STATUS IN 1 WORD           MOVE.W  D3,>FDCST               ;ABSPEICHERN            ANDI    =$D8FF,SR            QDPC *           MOVEA.L STATUS.X,A3            MOVE.W  D3,(A3)            RETN * * SELECT DRIVE *  SPC SELDRV ENTRY(FIXED(15),FIXED(15)) GLOBAL; *  CALL SELDRV(DRIVE,SIDE); * >SELDRV    ENTR    WSPSZ.L            VARW    WDRIVE.X            VARW    WSIDE.X            EPAR * BYTE FUER PSG BEREITSTELLEN            MOVE.W  WSIDE.X,D2            ANDI.W  =$01,D2         ;SIDE0 = 0,SIDE1 = 1            MOVE.W  WDRIVE.X,D3            ANDI.W  =$01,D3         ;DRIVE0 == 0,DRIVE1 ==1            ADDQ.W  =$01,D3         ;DRIVE0 == 1,DRIVE1 ==2            LSL.W   =1,D3           ;DRIVE0 == 010B,DRIVE1 = 100B            OR.W    D2,D3            EORI.W  =DESEL,D3       ;INVERTIEREN            ANDI.W  =DESEL,D3       ;DRIVE0 =  10XB,DRIVE1 = 01XB * BEI PSG REGISTER AUSWAHL,LESEN,SCHREIBEN NICHT STOEREN LASSEN ! * IN D3 STEHT NEUE SIDE+DRIVE INFORMATION            OFF            MOVE.W  =FLOPPY,DMACTL  ;ZUGRIFF AUF FDC            MOVE.B  =IOPA,PSGSEL    ;SELECT PORT A FOR READING            MOVE.B  PSGPAR,D2       ;ALTEN WERT VON PORT A HOLEN            ANDI.W  =$00F8,D2            OR.W    D3,D2            MOVE.B  D3,PSGPAW *            ANDI    =$D8FF,SR            RETN * * DESELECT DRIVE *  SPC DESDRV ENTRY GLOBAL; *  CALL SELDRV; * >DESDRV    ENTR    WSPSZ.L            EPAR * BEI PSG REGISTER AUSWAHL,LESEN,SCHREIBEN NICHT STOEREN LASSEN !            OFF            MOVE.W  =FLOPPY,DMACTL       ;ZUGRIFF AUF FDC            MOVE.B  =IOPA,PSGSEL         ;SELECT PORT A FOR READING            MOVE.B  PSGPAR,D2            ;ALTEN WERT VON PORT A HOLEN            ORI.B   =DESEL,D2            MOVE.B  D2,PSGPAW *            ANDI    =$D8FF,SR            RETN * * SET BUFFER ADDRESS FOR DMA *  SPC SETDMA ENTRY (FIXED(31)) GLOBAL; *  DCL BUFPTR FIXED(31); *  CALL SETDMA(BUFPTR); * * SCHREIB-REIHENFOLGE LOW,MID,HIG * BYTE       EQU     $08 * >SETDMA    ENTR    WSPSZ.L            VARX    BUFPTR.X            EPAR            OFF           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG            ANDI    =$D8FF,SR            RETN * * GET INTERRUPT VECTOR *  SPC GETVEC ENTRY(FIXED(15)) RETURNS(FIXED(31)) GLOBAL; *  DCL VEC FIXED(31); *  VEC = GETVEC(71); * * >GETVEC    ENTR    WSPSZ.L            VARW    VECNO.X            VARX    VECALT.Z            EPAR            MOVEA.L VECALT.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVEQ   =0,D3       ;CLEAR D3            MOVE.W  VECNO.X,D3            ASL.L   =2,D3       ;VECNO SHIFTLEFT 2 == VECNO MAL 4 => ADRESSE            MOVEA.L D3,A0            OFF            MOVE.L  (A0),(A3)   ;VEKTOR ALS RETURN VALUE ABLEGEN            ANDI    =$D8FF,SR            RETN * * SET INTERRUPT VECTOR *  SPC SETVEC ENTRY(FIXED(15),FIXED(31)) RETURNS(FIXED(31)) GLOBAL; *  DCL (VECALT,VECNEU) FIXED(31); *  DCL  VECNO FIXED(15); *  VECALT = SETVEC(VECNO,VECNEU); * * >SETVEC    ENTR    WSPSZ.L            VARW    VECNO.X            VARX    VECNEU.X            VARX    VECALT.Z            EPAR * ALTEN VEKTOR ZURUECKGEBEN            MOVEA.L VECALT.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVEQ   =0,D3       ;CLEAR D3            MOVE.W  VECNO.X,D3            ASL.L   =2,D3       ;VECNO SHIFTLEFT 2 == VECNO MAL 4 => ADRESSE            MOVEA.L D3,A0       ;IN A0 (VEKTORADRESSE IN LOW MEMORY) ABLEGEN            OFF            MOVE.L  (A0),(A3)   ;VEKTOR ALS RETURN VALUE ABLEGEN * NEUEN VEKTOR LADEN            MOVE.L  VECNEU.X,(A0) ;NEUEN VEKTORWERT LADEN            MOVE.B  (A3),(A0)     ;RECOVER MSB OF VECTOR            ANDI    =$D8FF,SR            RETN * * DO THE INTERRUPT VECTOR SETTING * (DEMO-ROUTINE,WIE MAN VON ASM AUS PROCEDURES AUFRUFT *  SPC DOSVEC ENTRY GLOBAL; * >DOSVEC    ENTR    WSPSZ.L            EPAR *            MOVE.W =79,ZECNO.X            MOVE.L =$77773333,ZECNEU.X * VIRTUELL WEITER * * ACHTUNG ZU PARAMETERUEBERGABE: ZECALT HIER PER VALUE * ZU UEBERGEBEN, AUFGERUFENE PROZEDUR SIEHT ES ALS IDENT !! * DIE AUFRUFENDE PROZEDUR WILL DAS ERGEBNIS JA ALS VALUE NUTZEN *            TOV            PROC    >SETVEC            VARW    ZECNO.X            VARX    ZECNEU.X            VARX    ZECALT.X            EPAR * HIER 68XXX CODE            RETN * * SUSPEND USER-TASK *  SPC SUSPUT ENTRY(CHAR(6)) GLOBAL; *  CALL SUSPUT('TASKNA'); * * FALLS TASK NAME >6, DANN AUCH IM PWS AENDERN ! * TNAML      EQU     6           ;TASK NAMEN LAENGE CHARTP     EQU     $08         ;DTYP * DTYP       DC.B    TNAML,CHARTP * >SUSPUT    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            EPAR            TOV            SUSE    UTNAME.X            TOREAL * HIER 68XXX CODE            RETN * * CONTINUE USER-TASK *  SPC CONTUT ENTRY(CHAR(6)) GLOBAL; *  CALL CONTUT('TASKNA'); * >CONTUT    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            EPAR            TOV            CONT    UTNAME.X            TOREAL * HIER 68XXX CODE            RETN * * SEARCH FOR TASK BY NAME *  SPC SRCHUT ENTRY(CHAR(6)) RETURNS(FIXED(31)) GLOBAL; *  DCL TSPTR FIXED(31); *  TSPTR = SRCHUT('TASKNA'); * * >SRCHUT    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            VARX    MDFND.Z            EPAR * STRING END $FF ABSPEICHERN            MOVE.W  =$FFFF,NAMEND.X            MOVEA.L MDFND.X,A3            LEA     UTNAME.X,A2            ITBS            BEQ     FOUND * MODULE NOT FOUND NFOUND     MOVE.L  =0,(A3)            BRA     FENDE * MODULE FOUND FOUND      MOVE.L  A1,D3            MOVE.L  D3,(A3) FENDE      RETN * * SEARCH FOR MODULE BY NAME *  SPC SRCHMD ENTRY(CHAR(6)) RETURNS(FIXED(31)) GLOBAL; *  DCL MDPTR FIXED(31); *  MDPTR = SRCHMD('MODNAM'); * * >SRCHMD    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            VARX    MDFND.Z            EPAR * STRING END $FF ABSPEICHERN            MOVE.W  =$FFFF,NAMEND.X            MOVEA.L MDFND.X,A3            LEA     UTNAME.X,A2            IMBS            BEQ     FOUND            BRA     NFOUND * * HIER GEHTS NICHT WEITER ! * * * GET TASKHEADER *  SPC GETTSH ENTRY(CHAR(6)) RETURNS(FIXED(31)) GLOBAL; *  DCL THPTR FIXED(31); *  THPTR = GETTSH('TASKNA') * * REGISTERVERWENDUNG * A0 = POINTER,ENTHAELT LASTMT * D2 = MODUL-TYP DES M/T HEADERS,.W ZEROPOINTER * D4.L,D5.W = TASKNAME * TPTASK     EQU     $01         ;M/T TYPE-BYTE MASKE FUER TASKS * * IN DIESER VERSION NUR HANDELN VON 6BYTE TASKNAMEN *  NICHT FERTIGGESTELLT !!!! * >GETTSH    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            VARX    MDFND.Z            EPAR            MOVE.W  =$FFFF,NAMEND.X ; STRING END $FF ABSPEICHERN            MOVEA.L MDFND.X,A3      ;ZEROPOINTER IST DEFAULTERGEBNIS            MOVE.L  =0,(A3)            MOVEA.L TID,A0          ; A0 MIT ADR DES EIGENEN THD LADEN * INIT 6BYTE TNAMEN            MOVE.L  UTNAME.X,D4     ;1TEIL DES TASKNAMENS            MOVE.W  (UTNAME+4).X,D5 ;2TEIL DES TASKNAMENS * * LOOP BEGIN * MODUL      MOVEA.L LASTMT(A0),A0            CMPA.L  =0,A0            BEQ     ENDE        ;BRA WENN POINTER = ZERO * WEITER,POINTER NICHT ZERO            MOVE.W  TASKTP(A0),D2            ANDI.W  =TPTASK,D2  ;MASKE OB TASK ODER MODUL            BEQ     MODUL       ;BRA FALLS MODUL, NAECHSTEN LINK VERSUCHEN * WEITER,ES LIEGT TASK VOR            MOVEQ   =0,D2            CMP.W   (TNAME+4)(A0),D2    ;LANGE FORM DES TNAMENS?            BEQ     LANGFM      ;BRA WENN LANGER NAMEN * HIER 6BYTE TASKNAMEN            CMP.L   TNAME(A0),D4            BNE     MODUL            CMP.W   (TNAME+4)(A0),D5            BNE     MODUL            BRA     THFND       ;NAME GEFUNDEN * HIER LANGE FOR DES TNAMENS LANGFM     BRA     MODUL       ;ZUR ZEIT UEBERGANGEN * NAMEN GEFUNDEN, TASK HEADER ADR SPEICHERN THFND      MOVEA.L MDFND.X,A3            MOVE.L  A0,(A3) ENDE       RETN * * CONTINUE SYSTEM-TASK *  SPC CONTST ENTRY(CHAR(6)) GLOBAL; *  CALL CONTST('TASKNA'); * >CONTST    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            EPAR * HIER VIRTUELL WEITER            TOV            PROC    >GETTSH            MPXF    DTYP,UTNAME.X            VARX    MDFND.X            EPAR * HIER WEITER MIT 68XXX            MOVEA.L MDFND.X,A0            CMPA.L  =0,A0            BEQ     NTFND1 * INS OFF, UNGESTOERT *          OFF *          MOVE.B  =$10,BLOCK(A0) *          ANDI    =$D8FF,SR            BCLR    =BLKBSU,BLOCK(A0) NTFND1     RETN * * SUSPEND SYSTEM-TASK *  SPC SUSPST ENTRY(CHAR(6)) GLOBAL; *  CALL SUSPST('TASKNA'); * >SUSPST    ENTR    WSPSZ.L            MPXF    DTYP,UTNAME.X            EPAR * HIER VIRTUELL WEITER            TOV            PROC    >GETTSH            MPXF    DTYP,UTNAME.X            VARX    MDFND.X            EPAR * HIER WEITER MIT 68XXX            MOVEA.L MDFND.X,A0            CMPA.L  =0,A0            BEQ     NTFND2 * INS OFF, DA LOESCHEN VON BLOCK NOETIG * SCHED+SUSP PASSEN NICHT ZUSAMMEN ,$10 == BIT 4            OFF            MOVE.B  =$10,BLOCK(A0)            ANDI    =$D8FF,SR NTFND2     RETN * * INTERRUPT HANDLER FOR FDC * *  VERWENDUNG VON D2,D3,A0 * FLPTRG     EQU     10000000    ;FLOPPY CMD FINISHED IRQ IVEC       EQU     IRDMAV      ;INTR-VECTOR ADRESSE DMA (V71) * >FDCST     DC.W    0           ;FDC+DMA STATUS REGISTER CONTENTS >FDCID     DC.L    0           ;ID DER BEFEHLGEBENDEN TASK(ADDRESS) *>DMAADR    DC.B    0           ;DMA ADRESSE BEI CMD-ENDE>HIGDMA    DC.B    0>MIDDMA    DC.B    0>LOWDMA    DC.B    0* RUECKL     DC      IRMAL-IRENT         ;RUECKFALL-LINK IRENT      MOVE    IID,-(A7)           ;SAVE OLD IID            MOVE    =IVEC,IID           ;FOR ANY MALFUNCTION-PROCESS            MOVEM.L D2-D3/D7/A0,-(A7)   ;SAVE REGISTERS ** DMA ADRESSE (BEI CMD-ENDE) ABLEGEN *  REIHENFOLGE UMGEKEHRT WIE BEIM SCHREIBEN, ALSO*  HIG,MID,LOW*           MOVE.B  DMAHIG,>HIGDMA           MOVE.B  DMAMID,>MIDDMA           MOVE.B  DMALOW,>LOWDMA** DMA STATUS REGISTER LESEN*           MOVE.W  DMASTA,D2           ANDI.W  =$0007,D2 ;DMA STATUS IST 3 BIT BREIT            ASL.W   =BYTE,D2  ;STATUS IN HIGH BYTE SCHIEBEN* * FDC STATUSREGISTER LESEN *            MOVE.W  =(FLOPPY+FRSTAT),DMACTL ;ZUGRIFF AUF FDC STATUSREG            MOVE.W  DSKDAT,D3               ;FDC STATUS LESEN            ANDI.W  =$00FF,D3               ;FDC REGISTER IST 8BIT BREIT            OR.W    D2,D3                   ;FDC,DMA STATUS IN 1 WORD           MOVE.W  D3,>FDCST               ;ABSPEICHERN * * CONTINUE CALLING TASK *            MOVEA.L >FDCID,A0            BCLR    =BLKBSU,BLOCK(A0)            SUBQ    =1,DPC              ;MARK DPC-CALL            MOVEM.L (A7)+,D2-D3/D7/A0   ;REGISTER RUECKLADEN            MOVE.W  (A7)+,IID           ;ALTEN INTERRUPT ID HOLEN            JMP     DISEX               ;CALL DISPATCHER * * MALFUNCTION ROUTINE * IRMAL      MOVEM.L (A7)+,D2-D3/D7/A0   ;REGISTER RUECKLADEN            MOVE.W  (A7)+,IID           ;ALTEN INTERRUPT ID HOLEN            RTE                         ;NORMAL EXIT * * GET DMA-INTERRUPT HANDLER VECTOR *  SPC GETIHD ENTRY RETURNS(FIXED(31)) GLOBAL; *  DCL VECALT FIXED(31); *  VECALT = GETIHD; * >GETIHD    ENTR    WSPSZ.L            VARX    VECALT.Z            EPAR            MOVEA.L VECALT.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            LEA     IRENT,A0            MOVE.L  A0,(A3)     ;VEKTOR ALS RETURN VALUE ABLEGEN            RETN * * KONSTANTEN FUER FLOPPY CMD REGISTER * WRDELA     EQU     $01         ;WRITE DELETED DATA MARK WRITEP     EQU     $02         ;DISABLE WRITE PRECOMPENSATION SEKRAT     EQU     $03         ;MAXIMALE STEPRATE 11B = 6MSEC SETDL      EQU     $04         ;ADD 30MS DELAY VERIFY     EQU     $04         ;VERIFY DESTINATION TRACK DISMO      EQU     $08         ;DISABLE MOTOR-ON-TEST  UPDATE     EQU     $10         ;UPDATE TRACK REGISTER MULTIS     EQU     $10         ;MULTIPLE SECTOR * RESTOR     EQU     SEKRAT+VERIFY SEEK       EQU     SEKRAT+VERIFY+$10 STEP       EQU     SEKRAT+VERIFY+UPDATE+$20 STEPIN     EQU     SEKRAT+VERIFY+UPDATE+$40 STEPOU     EQU     SEKRAT+VERIFY+UPDATE+$60 READS      EQU     SETDL+$80   READSM     EQU     MULTIS+SETDL+$80WRITS      EQU     SETDL+$A0WRITSM     EQU     MULTIS+SETDL+$A0  READAD     EQU     $C0  ;OHNE SETDL !!!!READT      EQU     SETDL+$E0 WRITET     EQU     WRITEP+SETDL+$F0 FORCIR     EQU     $D4 * * * RESET THE FDC WITH INTERRUPT ON CMD FINISH *  SPC IRESET ENTRY RETURNS(FIXED(15)) GLOBAL; *  DCL ERROR FIXED(15); *  ERROR =IRESET; * * ACHTUNG: JEDES INDEXLOCH EIN IRQ,KEINE IRQ BEENDIGUNG* NACH 1X IRQ * >IRESET    ENTR    WSPSZ.L            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF            MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;ZUGRIFF AUF FDC CMDREG            MOVE.W  =FORCIR,DSKDAT ;WRITE THE RESET CMD            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * TRACK 0 SUCHEN (RESTORE)*  SPC SEEKT0 ENTRY RETURNS(FIXED(15)) GLOBAL; *  DCL ERROR FIXED(15); *  ERROR = SEEKT0; * >SEEKT0    ENTR    WSPSZ.L            VARW    FDCERR.Z            EPAR           MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF            MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =RESTOR,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * STELLE AUF UEBERGEBENEN TRACK EIN *  SPC SEEKTR ENTRY(FIXED(15)) RETURNS(FIXED(15)) GLOBAL; *  DCL (ERROR,TRACK) FIXED(15); *  ERROR = SEEKTR(TRACK); * * ROUTINE GEHT NUR SO FUER 1 LAUFWERK-HARDWARE * >SEEKTR    ENTR    WSPSZ.L            VARW    TRACK.X            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF            MOVE.W  =(FLOPPY+FRDATA),DMACTL  ;WRITE TO FDC DATAREG            MOVE.W  TRACK.X,DSKDAT              ;TRACK SCHREIBEN            MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =SEEK,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * GET TRACK REGISTER *  SPC GETTR ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL TRACK FIXED(15); *  TRACK = GETTR; * >GETTR     ENTR    WSPSZ.L            VARW    TRACKR.Z            EPAR           OFF            MOVE.W  =(FLOPPY+FRTRCK),DMACTL     ;READ FROM FDC TRACKREG            MOVE.W  DSKDAT,D3   ;TRACK LESEN            ANDI    =$D8FF,SR            QDPC            ANDI.W  =$00FF,D3               ;TRACK REGISTER IST 8BIT BREIT            MOVEA.L TRACKR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN           MOVE.W  D3,(A3)     ;TRACK ALS RETURN VALUE ABLEGEN            RETN * * SET TRACK REGISTER *  SPC SETTR ENTRY (FIXED(15)) GLOBAL;*  DCL TRACK FIXED(15); *  CALL SETTR(TRACK); * >SETTR     ENTR    WSPSZ.L            VARW    TRACK.X            EPAR           OFF            MOVE.W  =(FLOPPY+FRTRCK),DMACTL     ;WRITE TO FDC TRACKREG            MOVE.W  D3,DSKDAT   ;TRACK AN FDC            ANDI    =$D8FF,SR            RETN * * STEP FDC *  SPC FDSTEP ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL ERROR) FIXED(15); *  ERROR = FDSTEP; * >FDSTEP    ENTR    WSPSZ.L            VARW    FDCERR.Z            EPAR           MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF           MOVE.W  =(FLOPPY+FRCMD),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  =STEP,DSKDAT   ;STEP CMD AN FDC            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * STEPIN FDC *  SPC FDSTIN ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL ERROR) FIXED(15); *  ERROR = FDSTIN; * >FDSTIN    ENTR    WSPSZ.L            VARW    FDCERR.Z             EPAR           MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF           MOVE.W  =(FLOPPY+FRCMD),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  =STEPIN,DSKDAT   ;STEPIN CMD AN FDC            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * STEP OUT FDC *  SPC FDSTOU ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL ERROR) FIXED(15); *  ERROR = FDSTOU; * >FDSTOU    ENTR    WSPSZ.L            VARW    FDCERR.Z             EPAR           MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF           MOVE.W  =(FLOPPY+FRCMD),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  =STEPOU,DSKDAT   ;STEPOU CMD AN FDC            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN * * GET SECTOR REGISTER *  SPC GETSEC ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL SECTOR FIXED(15); *  SECTOR = GETSEC; * >GETSEC    ENTR    WSPSZ.L            VARW    SECTOR.Z            EPAR           OFF            MOVE.W  =(FLOPPY+FRSECT),DMACTL READ FROM FDC SECTORREG            MOVE.W  DSKDAT,D3   ;SECTOR LESEN            ANDI    =$D8FF,SR            QDPC            ANDI.W  =$00FF,D3   ;SECTOR REGISTER IST 8BIT BREIT            MOVEA.L SECTOR.X,A3   ;ADRESSE FUER RETURN VALUE LADEN           MOVE.W  D3,(A3)     ;TRACK ALS RETURN VALUE ABLEGEN            RETN * * GET BUFFER ADDRESS *  SPC GETBUF ENTRY RETURNS(FIXED(31)) GLOBAL; *  DCL BUFADR FIXED(31); *  BUFADR = GETBUF; *>GETBUF    ENTR    WSPSZ.L            VARX    BUFADR.Z            EPAR           LEA     >BUFFER,A1  ;BUFFERADRESSE LADEN           MOVEA.L BUFADR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.L  A1,(A3)     ;ADRESSE ALS RETURN VALUE ABLEGEN            RETN ** CLEAR BUFFER WITH $00*  SPC CLRBUF ENTRY GLOBAL; *  CALL CLRBUF;** BEZIEHT SICH AUF BUFFER ,* BUFFERGROESSE IST BUFSIZ*>CLRBUF    ENTR   WSPSZ.L           EPAR           MOVE.L =(BUFSIZ-1),D2           LEA    >BUFFER,A0           MOVE   =0,D3** LOOP TO CLEAR THE BUFFER, BIS D2 = -1*CLOOP      MOVE.B D3,(A0)+                      DBF    D2,CLOOP            *           RETN ** READ WHOLE TRACK WITH ALL SYNCS*  SPC RSTRCK ENTRY (FIXED(31)) RETURNS FIXED(15) GLOBAL;*  DCL ERROR FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= RSTRCK(BUFPTR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN *>RSTRCK    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF LESEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT*           MOVE.W  =SECMAX,DSKDAT ; SECTOR COUNT AN DMA** EIGENTLICHER FLOPPY BEFEHL READ TRACK*           MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =READT,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** READ ADDRESS FIELDS*  SPC RDADR ENTRY (FIXED(31)) RETURNS(FIXED(15)) GLOBAL;*  DCL ERROR FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= RDADR(BUFPTR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN * HIER 32 X 6 = 192 BYTES KLEINER ALS 512 BYTES, ALSO* 1 SECTOR  ZU UEBERTRAGEN*ADZAHL     EQU     32     ;32+1 ADRESSFELDER LESEN*>RDADR     ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG *           MOVE.W  =ADZAHL,D2      ; COUNTER ADRESSFELDER ZAHL** DMA-REGISTER LOESCHEN UND AUF LESEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT*           MOVE.W  =1,DSKDAT ; 1 SEKTOR LESEN AN DMA UEBERGEBEN** SCHLEIFE: ALLE ADRESSFELDER LESEN* EIGENTLICHER FLOPPY BEFEHL READ ADDRESS MARK*LOOPA      OFF           MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =READAD,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            DBF     D2,LOOPA** SCHLEIFENENDE* HIER ALLE ADRESSFELDER GELESEN:*           MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** GET CURRENT TRACK*  SPC GETCT ENTRY RETURNS(FIXED(15)) GLOBAL;*  DCL ERROR FIXED(15);*  ERROR:= RDADR(BUFPTR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN * HIER 6 BYTES KLEINER ALS 512 BYTES, ALSO* 1 SECTOR  ZU UEBERTRAGEN**>GETCT     ENTR    WSPSZ.L            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** KEINE DMA ADDRESS SETZEN, DA KEINE DATEN IN DEN*  SPEICHER UEBERTRAGEN WERDEN           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF LESEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT*           MOVE.W  =1,DSKDAT ; 1 SEKTOR LESEN AN DMA UEBERGEBEN** EIGENTLICHER FLOPPY BEFEHL READ ADDRESS MARK*           MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =READAD,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ ** DMA BUFFER LOESCHEN, DA KEINE DATEN IN SPEICHER ZU UEBERTRAGEN*           OFF           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** HIER ADRESSFELD GELESEN, CURRENT TRACK IM SECTORREGISTER:*  (UEBER GETSEC WEITER ZU VERARBEITEN, HIER NUR RUECKGABE*  DES FEHLERSTATUS) *           MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** READ SECTOR*  SPC READSC ENTRY (FIXED(31),FIXED(15)) RETURNS(FIXED(15)) GLOBAL;*  DCL (SECTOR,ERROR) FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= READSC(BUFPTR,SECTOR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN  *>READSC    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    SECR.X                     VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SECTOR AN FDC UEBERGEBEN*           MOVE.W  =(FLOPPY+FRSECT),DMACTL WRITE TO FDC SECTORREG            MOVE.W  SECR.X,DSKDAT   ;SECTOR AN FDC ** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF LESEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT *           MOVE.W  =SECMAX,DSKDAT ; MAX SECTOR LESEN AN DMA** EIGENTLICHER FLOPPY BEFEHL READ SECTOR*           MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =READS,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** READ MULTIPLE SECTORS*  SPC READMS ENTRY (FIXED(31),FIXED(15)) RETURNS(FIXED(15)) GLOBAL;*  DCL (SECTOR,ERROR) FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= READMS(BUFPTR,SECTOR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN  *>READMS    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    SECR.X                     VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SECTOR AN FDC UEBERGEBEN*           MOVE.W  =(FLOPPY+FRSECT),DMACTL WRITE TO FDC SECTORREG            MOVE.W  SECR.X,DSKDAT   ;SECTOR AN FDC ** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF LESEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT *           MOVE.W  =SECMAX,DSKDAT ; MAX SECTOR LESEN AN DMA** EIGENTLICHER FLOPPY BEFEHL READ MULTIPLE SECTORS*           MOVE.W  =(FLOPPY+FRCMD),DMACTL   ;WRITE TO FDC CMDREG            MOVE.W  =READSM,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** WRITE WHOLE TRACK WITH ALL SYNCS*  SPC WSTRCK ENTRY (FIXED(31)) RETURNS FIXED(15) GLOBAL;*  DCL ERROR FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= WSTRCK(BUFPTR); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN *>WSTRCK    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF SCHREIBEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL  ** BEGINN DES DMA TRANSFERS*           MOVE.W  =SECMAX,DSKDAT ; SECTOR COUNT AN DM** EIGENTLICHER FLOPPY BEFEHL WRITE TRACK*           MOVE.W  =(FLOPPY+FRCMD+FRWRIT),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  =WRITET,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** WRITE SECTOR*  SPC WRITSC ENTRY (FIXED(31),FIXED(15),FIXED(15)) *             RETURNS(FIXED(15)) GLOBAL;*  DCL (SECTOR,DATAMARK,ERROR) FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= WRITSC(BUFPTR,SECTOR,DATAMARK); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN  *>WRITSC    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    SECR.X                     VARW    DATAMK.X           VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SECTOR AN FDC UEBERGEBEN*           MOVE.W  =(FLOPPY+FRSECT+FRWRIT),DMACTL ;WRITE TO FDCSECTORREG            MOVE.W  SECR.X,DSKDAT   ;SECTOR AN FDC ** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF SCHREIBEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL  ** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT *           MOVE.W  =SECMAX,DSKDAT ; MAX SECTOR LESEN AN DMA** EIGENTLICHER FLOPPY BEFEHL WRITE SECTOR*           MOVE.W  =(FLOPPY+FRCMD+FRWRIT),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  DATAMK.X,D2   ;WRITS MIT DATAMK VERKNUEPFEN           ANDI.W  =1,D2         ;D2 = 0: NORMALES DATA MARK           ORI.W   =WRITS,D2     ;D2 = 1: DELETED DATA MARK           MOVE.W  D2,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN** WRITE MULTIPLE SECTORS*  SPC WRITMS ENTRY (FIXED(31),FIXED(15),(FIXED(15)) *      RETURNS(FIXED(15)) GLOBAL;*  DCL (SECTOR,DATAMARK,ERROR) FIXED(15);*  DCL BUFPTR FIXED(31);*  ERROR:= WRITMS(BUFPTR,SECTOR,DATAMARK); ** DMA MUSS ANZAHL DATEN-SECTOR (A 512 BYTES) MITGETEILT WERDEN  *>WRITMS    ENTR    WSPSZ.L            VARX    BUFPTR.X            VARW    SECR.X                     VARW    DATAMK.X           VARW    FDCERR.Z            EPAR            MOVE.L TID,>FDCID   ;TID DES AUFRUFENDEN TASKS RETTEN            MOVE.W =$FFFF,>FDCST    ;STATUS ALS UNGUELTIG MARKIEREN            OFF** SECTOR AN FDC UEBERGEBEN*           MOVE.W  =(FLOPPY+FRSECT+FRWRIT),DMACTL ;WRITE TO DMASECTORREG            MOVE.W  SECR.X,DSKDAT   ;SECTOR AN FDC ** SET DMA ADDRESS*           MOVE.L  BUFPTR.X,D3            MOVE.B  D3,DMALOW            LSR.L   =BYTE,D3            MOVE.B  D3,DMAMID            LSR.L   =BYTE,D3            MOVE.B  D3,DMAHIG ** DMA-REGISTER LOESCHEN UND AUF SCHREIBEN EINSTELLEN* DURCH TOGGELN VON DMACTL* (SIEHE HITCHHIKERS GUIDE SEITE 59,DATA BECKER *  FLOPPY BUCH SEITE 346)*           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL             MOVE.W  =(FLOPPY+FRSCNT),DMACTL     ;ACCES SECCNT REG           MOVE.W  =(FLOPPY+FRSCNT+FRWRIT),DMACTL  ** BEGINN DES DMA TRANSFERS*  DURCH SCHREIBEN AUF SECCOUNT *           MOVE.W  =SECMAX,DSKDAT ; MAX SECTOR LESEN AN DMA** EIGENTLICHER FLOPPY BEFEHL WRITE MULTIPLE SECTORS*           MOVE.W  =(FLOPPY+FRCMD+FRWRIT),DMACTL ;WRITE TO FDC CMDREG            MOVE.W  DATAMK.X,D2   ;WRITS MIT DATAMK VERKNUEPFEN           ANDI.W  =1,D2         ;D2 = 0: NORMALES DATA MARK           ORI.W   =WRITSM,D2    ;D2 = 1: DELETED DATA MARK           MOVE.W  D2,DSKDAT            ANDI    =$D8FF,SR            SUSP                ;WARTEN BIS IRQ            MOVEA.L FDCERR.X,A3 ;ADRESSE FUER RETURN VALUE LADEN            MOVE.W  >FDCST,(A3) ;STATUS ALS RETURN VALUE ABLEGEN            RETN*            END * 